# 🚀 Sepulki Deployment Guide

Complete guide for deploying Sepulki from local development to production with automatic environment switching.

## 🎯 **Environment Switching Overview**

Sepulki automatically detects and switches between environments based on:

1. **`NODE_ENV`** environment variable
2. **Deployment platform detection** (Vercel, Railway, etc.)
3. **Available authentication providers**
4. **Database and service URLs**

### **Environment Detection Logic:**

```typescript
// Local Development (Default)
NODE_ENV=development
→ Mock authentication active
→ Local database (PostgreSQL at localhost)
→ Local services (Redis, MinIO)

// Production Deployment  
NODE_ENV=production + GITHUB_CLIENT_ID set
→ Real GitHub OAuth authentication
→ Production database (from DATABASE_URL)
→ Production services (Redis, S3, etc.)
```

## 🛠️ **Deployment Options**

### **Option 1: Vercel (Recommended)**

**Step 1: Set Environment Variables**
```bash
# Authentication
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
NEXTAUTH_SECRET=your_secure_random_string
NEXTAUTH_URL=https://your-app.vercel.app

# Database (Supabase/PlanetScale/Railway)
DATABASE_URL=postgresql://user:pass@host:port/database

# Redis (Upstash/Railway)
REDIS_URL=rediss://user:pass@host:port

# Email (SendGrid/Resend)
EMAIL_SERVER=smtps://apikey:your_key@smtp.sendgrid.net:465
EMAIL_FROM=noreply@yourdomain.com

# GraphQL Endpoint (auto-detected from VERCEL_URL)
NEXT_PUBLIC_GRAPHQL_ENDPOINT=https://your-app.vercel.app/api/graphql
```

**Step 2: Deploy**
```bash
# Connect to Vercel
npx vercel

# Deploy
npx vercel --prod
```

**✅ Result:** Automatic production mode with GitHub OAuth!

---

### **Option 2: Railway**

**Step 1: Create Railway Project**
```bash
# Install Railway CLI
npm install -g @railway/cli

# Login and create project
railway login
railway init sepulki
```

**Step 2: Set Environment Variables**
```bash
# Authentication
railway vars:set GITHUB_CLIENT_ID=your_client_id
railway vars:set GITHUB_CLIENT_SECRET=your_secret
railway vars:set NEXTAUTH_SECRET=your_random_string

# Database (Railway provides this automatically)
# DATABASE_URL is auto-generated by Railway

# Redis (Railway provides this automatically)  
# REDIS_URL is auto-generated by Railway
```

**Step 3: Deploy**
```bash
railway up
```

**✅ Result:** Automatic production mode with managed database & Redis!

---

### **Option 3: Docker/Kubernetes**

**Step 1: Create Production Dockerfile**
```dockerfile
# apps/forge-ui/Dockerfile
FROM node:18-alpine AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

FROM node:18-alpine AS builder
WORKDIR /app
COPY . .
COPY --from=deps /app/node_modules ./node_modules
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app/next.config.js ./
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

EXPOSE 3000
CMD ["npm", "start"]
```

**Step 2: Environment Variables**
```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  sepulki-app:
    build: .
    environment:
      NODE_ENV: production
      GITHUB_CLIENT_ID: ${GITHUB_CLIENT_ID}
      GITHUB_CLIENT_SECRET: ${GITHUB_CLIENT_SECRET}
      DATABASE_URL: ${DATABASE_URL}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET}
    ports:
      - "3000:3000"
```

---

### **Option 4: Traditional VPS/EC2**

**Step 1: Server Setup**
```bash
# On your server
git clone https://github.com/yourusername/Sepulki.git
cd Sepulki
npm install
npm run build
```

**Step 2: Environment Configuration**
```bash
# Create .env.production
cat > .env.production << EOF
NODE_ENV=production
GITHUB_CLIENT_ID=your_client_id
GITHUB_CLIENT_SECRET=your_secret
DATABASE_URL=postgresql://user:pass@host:port/db
REDIS_URL=redis://host:port
NEXTAUTH_SECRET=your_secret
NEXTAUTH_URL=https://yourdomain.com
EOF
```

**Step 3: Start Production Server**
```bash
# Using PM2
npm install -g pm2
pm2 start npm --name "sepulki" -- start
pm2 save
pm2 startup
```

## 🔐 **Authentication Provider Setup**

### **GitHub OAuth**
1. Go to [github.com/settings/applications/new](https://github.com/settings/applications/new)
2. Set **Authorization callback URL**: `https://yourdomain.com/api/auth/callback/github`
3. Copy Client ID and Secret to your environment variables

### **Google OAuth (Alternative)**
1. Go to [Google Cloud Console](https://console.developers.google.com/)
2. Create OAuth 2.0 credentials
3. Set redirect URI: `https://yourdomain.com/api/auth/callback/google`  
4. Add `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` to environment

## 💾 **Database Options**

### **Supabase (Recommended)**
```bash
# Automatic PostgreSQL with built-in auth
DATABASE_URL=postgresql://postgres:[password]@[host]:5432/postgres
```

### **PlanetScale**
```bash  
# Serverless MySQL (compatible with PostgreSQL queries)
DATABASE_URL=mysql://[user]:[password]@[host]/[database]?sslaccept=strict
```

### **Railway PostgreSQL**
```bash
# Automatically provided when you add PostgreSQL service
DATABASE_URL=postgresql://postgres:[password]@[host]:5432/railway
```

## 📧 **Email Service Setup**

### **SendGrid**
```bash
EMAIL_SERVER=smtps://apikey:your_sendgrid_api_key@smtp.sendgrid.net:465
EMAIL_FROM=noreply@yourdomain.com
```

### **Resend**
```bash
EMAIL_SERVER=smtps://resend:your_api_key@smtp.resend.com:465
EMAIL_FROM=noreply@yourdomain.com
```

## 🔍 **Environment Switching Verification**

After deployment, check that environment switching worked:

### **Local Development**
- Visit `http://localhost:3000`
- Should see: "🧪 Development Mode Active"
- Authentication: Mock user auto-login
- Database: Local PostgreSQL

### **Production Deployment**  
- Visit your production URL
- Should see: "🔐 Production Authentication"
- Authentication: GitHub/Google OAuth buttons
- Database: Production database from `DATABASE_URL`

### **Console Logs to Watch For**
```javascript
// Development
🧪 Using mock authentication in development mode
🔧 Auth providers configured: Development Smith

// Production  
🔐 Using real authentication providers: github
🔐 Auth providers configured: GitHub
```

## ⚡ **Quick Deploy Commands**

### **Deploy to Vercel**
```bash
# Set environment variables in Vercel dashboard, then:
npm run build && npx vercel --prod
```

### **Deploy to Railway**
```bash
# Environment variables set via Railway CLI:
railway vars:set GITHUB_CLIENT_ID=xxx
railway up
```

### **Deploy to Netlify**
```bash
# Set environment variables in Netlify dashboard, then:
npm run build && npx netlify deploy --prod --dir=out
```

## 🏥 **Health Checks**

Your deployment should pass these checks:

```bash
# Frontend health
curl https://yourdomain.com/api/health

# GraphQL health  
curl https://yourdomain.com/api/graphql/health

# Authentication check
curl https://yourdomain.com/api/auth/providers
```

## 🚨 **Common Issues & Solutions**

### **Issue: "No authentication providers configured"**
**Solution:** Set `GITHUB_CLIENT_ID` and `GITHUB_CLIENT_SECRET`

### **Issue: Database connection failed**
**Solution:** Verify `DATABASE_URL` format and network access

### **Issue: "NEXTAUTH_URL mismatch"**
**Solution:** Ensure `NEXTAUTH_URL` matches your production domain

### **Issue: CORS errors**
**Solution:** Update `CORS_ORIGIN` environment variable

## 🎯 **Production Checklist**

- [ ] `NODE_ENV=production` set
- [ ] OAuth provider configured (GitHub/Google)
- [ ] `NEXTAUTH_SECRET` is secure random string
- [ ] `NEXTAUTH_URL` matches production domain
- [ ] `DATABASE_URL` points to production database
- [ ] Email service configured
- [ ] Environment variables secured (not in code)
- [ ] HTTPS enabled with valid SSL certificate
- [ ] Health checks passing
- [ ] Login flow tested end-to-end

## 🎉 **Success!**

Once deployed, your Sepulki app will:

✅ **Automatically detect production environment**  
✅ **Switch from mock to real OAuth authentication**  
✅ **Connect to production database and services**  
✅ **Display production-appropriate UI**  
✅ **Handle user sessions and data securely**

Your developers can continue using the same codebase locally with mock auth, while production users get the full OAuth experience!
